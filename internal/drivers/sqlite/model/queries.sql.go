// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package model

import (
	"context"
	"strings"
)

const getCacheString = `-- name: GetCacheString :one
SELECT value
FROM cache
WHERE key = ?1
LIMIT 1
`

func (q *Queries) GetCacheString(ctx context.Context, key string) (string, error) {
	row := q.db.QueryRowContext(ctx, getCacheString, key)
	var value string
	err := row.Scan(&value)
	return value, err
}

const getMedia = `-- name: GetMedia :one
SELECT source_id, target_id FROM medias
WHERE source_id = ?1
LIMIT 1
`

func (q *Queries) GetMedia(ctx context.Context, id string) (Media, error) {
	row := q.db.QueryRowContext(ctx, getMedia, id)
	var i Media
	err := row.Scan(&i.SourceID, &i.TargetID)
	return i, err
}

const getMediaBulk = `-- name: GetMediaBulk :many
SELECT source_id, target_id FROM medias
WHERE source_id
IN (/*SLICE:source_ids*/?)
`

func (q *Queries) GetMediaBulk(ctx context.Context, sourceIds []string) ([]Media, error) {
	query := getMediaBulk
	var queryParams []interface{}
	if len(sourceIds) > 0 {
		for _, v := range sourceIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:source_ids*/?", strings.Repeat(",?", len(sourceIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:source_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Media
	for rows.Next() {
		var i Media
		if err := rows.Scan(&i.SourceID, &i.TargetID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const putCacheString = `-- name: PutCacheString :exec
REPLACE INTO cache (key, value)
VALUES (?1, ?2)
`

type PutCacheStringParams struct {
	Key   string
	Value string
}

func (q *Queries) PutCacheString(ctx context.Context, arg PutCacheStringParams) error {
	_, err := q.db.ExecContext(ctx, putCacheString, arg.Key, arg.Value)
	return err
}

const putMedia = `-- name: PutMedia :exec
REPLACE INTO medias (source_id, target_id)
VALUES (?1, ?2)
`

type PutMediaParams struct {
	SourceID string
	TargetID string
}

func (q *Queries) PutMedia(ctx context.Context, arg PutMediaParams) error {
	_, err := q.db.ExecContext(ctx, putMedia, arg.SourceID, arg.TargetID)
	return err
}
